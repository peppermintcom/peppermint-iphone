// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/datastore/v1beta3/entity.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "google/datastore/v1beta3/Entity.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
#import "google/protobuf/Struct.pbobjc.h"
#import "google/protobuf/Timestamp.pbobjc.h"
#import "google/type/Latlng.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - EntityRoot

@implementation EntityRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
    [registry addExtensions:[GPBStructRoot extensionRegistry]];
    [registry addExtensions:[GPBTimestampRoot extensionRegistry]];
    [registry addExtensions:[LatlngRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - EntityRoot_FileDescriptor

static GPBFileDescriptor *EntityRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.datastore.v1beta3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - PartitionId

@implementation PartitionId

@dynamic projectId;
@dynamic namespaceId;

typedef struct PartitionId__storage_ {
  uint32_t _has_storage_[1];
  NSString *projectId;
  NSString *namespaceId;
} PartitionId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "projectId",
        .number = PartitionId_FieldNumber_ProjectId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(PartitionId__storage_, projectId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "namespaceId",
        .number = PartitionId_FieldNumber_NamespaceId,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(PartitionId__storage_, namespaceId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PartitionId class]
                                     rootClass:[EntityRoot class]
                                          file:EntityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(PartitionId__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Key

@implementation Key

@dynamic hasPartitionId, partitionId;
@dynamic pathArray, pathArray_Count;

typedef struct Key__storage_ {
  uint32_t _has_storage_[1];
  PartitionId *partitionId;
  NSMutableArray *pathArray;
} Key__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "partitionId",
        .number = Key_FieldNumber_PartitionId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Key__storage_, partitionId),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(PartitionId),
        .fieldOptions = NULL,
      },
      {
        .name = "pathArray",
        .number = Key_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Key__storage_, pathArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key_PathElement),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Key class]
                                     rootClass:[EntityRoot class]
                                          file:EntityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Key__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Key_PathElement

@implementation Key_PathElement

@dynamic idTypeOneOfCase;
@dynamic kind;
@dynamic id_p;
@dynamic name;

typedef struct Key_PathElement__storage_ {
  uint32_t _has_storage_[2];
  NSString *kind;
  NSString *name;
  int64_t id_p;
} Key_PathElement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageOneofDescription oneofs[] = {
      {
        .name = "idType",
        .index = -1,
      },
    };
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "kind",
        .number = Key_PathElement_FieldNumber_Kind,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Key_PathElement__storage_, kind),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "id_p",
        .number = Key_PathElement_FieldNumber_Id_p,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(Key_PathElement__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "name",
        .number = Key_PathElement_FieldNumber_Name,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Key_PathElement__storage_, name),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Key_PathElement class]
                                     rootClass:[EntityRoot class]
                                          file:EntityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:oneofs
                                    oneofCount:sizeof(oneofs) / sizeof(GPBMessageOneofDescription)
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Key_PathElement__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Key_PathElement_ClearIdTypeOneOfCase(Key_PathElement *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, 0);
}
#pragma mark - ArrayValue

@implementation ArrayValue

@dynamic valuesArray, valuesArray_Count;

typedef struct ArrayValue__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *valuesArray;
} ArrayValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valuesArray",
        .number = ArrayValue_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(ArrayValue__storage_, valuesArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Value),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArrayValue class]
                                     rootClass:[EntityRoot class]
                                          file:EntityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(ArrayValue__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Value

@implementation Value

@dynamic valueTypeOneOfCase;
@dynamic nullValue;
@dynamic booleanValue;
@dynamic integerValue;
@dynamic doubleValue;
@dynamic timestampValue;
@dynamic keyValue;
@dynamic stringValue;
@dynamic blobValue;
@dynamic geoPointValue;
@dynamic entityValue;
@dynamic arrayValue;
@dynamic meaning;
@dynamic excludeFromIndexes;

typedef struct Value__storage_ {
  uint32_t _has_storage_[2];
  BOOL booleanValue;
  BOOL excludeFromIndexes;
  GPBNullValue nullValue;
  int32_t meaning;
  Key *keyValue;
  Entity *entityValue;
  LatLng *geoPointValue;
  ArrayValue *arrayValue;
  GPBTimestamp *timestampValue;
  NSString *stringValue;
  NSData *blobValue;
  int64_t integerValue;
  double doubleValue;
} Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageOneofDescription oneofs[] = {
      {
        .name = "valueType",
        .index = -1,
      },
    };
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "booleanValue",
        .number = Value_FieldNumber_BooleanValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(Value__storage_, booleanValue),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "integerValue",
        .number = Value_FieldNumber_IntegerValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(Value__storage_, integerValue),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "doubleValue",
        .number = Value_FieldNumber_DoubleValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
        .offset = offsetof(Value__storage_, doubleValue),
        .defaultValue.valueDouble = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "keyValue",
        .number = Value_FieldNumber_KeyValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Value__storage_, keyValue),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .fieldOptions = NULL,
      },
      {
        .name = "entityValue",
        .number = Value_FieldNumber_EntityValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Value__storage_, entityValue),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Entity),
        .fieldOptions = NULL,
      },
      {
        .name = "geoPointValue",
        .number = Value_FieldNumber_GeoPointValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Value__storage_, geoPointValue),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(LatLng),
        .fieldOptions = NULL,
      },
      {
        .name = "arrayValue",
        .number = Value_FieldNumber_ArrayValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Value__storage_, arrayValue),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ArrayValue),
        .fieldOptions = NULL,
      },
      {
        .name = "timestampValue",
        .number = Value_FieldNumber_TimestampValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Value__storage_, timestampValue),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .fieldOptions = NULL,
      },
      {
        .name = "nullValue",
        .number = Value_FieldNumber_NullValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Value__storage_, nullValue),
        .defaultValue.valueEnum = GPBNullValue_NullValue,
        .dataTypeSpecific.enumDescFunc = GPBNullValue_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "meaning",
        .number = Value_FieldNumber_Meaning,
        .hasIndex = 11,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(Value__storage_, meaning),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "stringValue",
        .number = Value_FieldNumber_StringValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Value__storage_, stringValue),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "blobValue",
        .number = Value_FieldNumber_BlobValue,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(Value__storage_, blobValue),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "excludeFromIndexes",
        .number = Value_FieldNumber_ExcludeFromIndexes,
        .hasIndex = 12,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(Value__storage_, excludeFromIndexes),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Value class]
                                     rootClass:[EntityRoot class]
                                          file:EntityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:oneofs
                                    oneofCount:sizeof(oneofs) / sizeof(GPBMessageOneofDescription)
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Value__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Value_NullValue_RawValue(Value *message) {
  GPBDescriptor *descriptor = [Value descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Value_FieldNumber_NullValue];
  return GPBGetMessageInt32Field(message, field);
}

void SetValue_NullValue_RawValue(Value *message, int32_t value) {
  GPBDescriptor *descriptor = [Value descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Value_FieldNumber_NullValue];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void Value_ClearValueTypeOneOfCase(Value *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, 0);
}
#pragma mark - Entity

@implementation Entity

@dynamic hasKey, key;
@dynamic properties, properties_Count;

typedef struct Entity__storage_ {
  uint32_t _has_storage_[1];
  Key *key;
  NSMutableDictionary *properties;
} Entity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .number = Entity_FieldNumber_Key,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Entity__storage_, key),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .fieldOptions = NULL,
      },
      {
        .name = "properties",
        .number = Entity_FieldNumber_Properties,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Entity__storage_, properties),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Value),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Entity class]
                                     rootClass:[EntityRoot class]
                                          file:EntityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Entity__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)
