// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/datastore/v1beta3/datastore.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "google/datastore/v1beta3/Datastore.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
#import "google/datastore/v1beta3/Entity.pbobjc.h"
#import "google/datastore/v1beta3/Query.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - DatastoreRoot

@implementation DatastoreRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
    [registry addExtensions:[EntityRoot extensionRegistry]];
    [registry addExtensions:[QueryRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - DatastoreRoot_FileDescriptor

static GPBFileDescriptor *DatastoreRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.datastore.v1beta3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - LookupRequest

@implementation LookupRequest

@dynamic projectId;
@dynamic hasReadOptions, readOptions;
@dynamic keysArray, keysArray_Count;

typedef struct LookupRequest__storage_ {
  uint32_t _has_storage_[1];
  ReadOptions *readOptions;
  NSMutableArray *keysArray;
  NSString *projectId;
} LookupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "readOptions",
        .number = LookupRequest_FieldNumber_ReadOptions,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LookupRequest__storage_, readOptions),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ReadOptions),
        .fieldOptions = NULL,
      },
      {
        .name = "keysArray",
        .number = LookupRequest_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LookupRequest__storage_, keysArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = LookupRequest_FieldNumber_ProjectId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LookupRequest__storage_, projectId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LookupRequest class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LookupRequest__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LookupResponse

@implementation LookupResponse

@dynamic foundArray, foundArray_Count;
@dynamic missingArray, missingArray_Count;
@dynamic deferredArray, deferredArray_Count;

typedef struct LookupResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *foundArray;
  NSMutableArray *missingArray;
  NSMutableArray *deferredArray;
} LookupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "foundArray",
        .number = LookupResponse_FieldNumber_FoundArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LookupResponse__storage_, foundArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(EntityResult),
        .fieldOptions = NULL,
      },
      {
        .name = "missingArray",
        .number = LookupResponse_FieldNumber_MissingArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LookupResponse__storage_, missingArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(EntityResult),
        .fieldOptions = NULL,
      },
      {
        .name = "deferredArray",
        .number = LookupResponse_FieldNumber_DeferredArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LookupResponse__storage_, deferredArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LookupResponse class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LookupResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RunQueryRequest

@implementation RunQueryRequest

@dynamic queryTypeOneOfCase;
@dynamic projectId;
@dynamic hasPartitionId, partitionId;
@dynamic hasReadOptions, readOptions;
@dynamic query;
@dynamic gqlQuery;

typedef struct RunQueryRequest__storage_ {
  uint32_t _has_storage_[2];
  ReadOptions *readOptions;
  PartitionId *partitionId;
  Query *query;
  GqlQuery *gqlQuery;
  NSString *projectId;
} RunQueryRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageOneofDescription oneofs[] = {
      {
        .name = "queryType",
        .index = -1,
      },
    };
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "readOptions",
        .number = RunQueryRequest_FieldNumber_ReadOptions,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RunQueryRequest__storage_, readOptions),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ReadOptions),
        .fieldOptions = NULL,
      },
      {
        .name = "partitionId",
        .number = RunQueryRequest_FieldNumber_PartitionId,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RunQueryRequest__storage_, partitionId),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(PartitionId),
        .fieldOptions = NULL,
      },
      {
        .name = "query",
        .number = RunQueryRequest_FieldNumber_Query,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RunQueryRequest__storage_, query),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Query),
        .fieldOptions = NULL,
      },
      {
        .name = "gqlQuery",
        .number = RunQueryRequest_FieldNumber_GqlQuery,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RunQueryRequest__storage_, gqlQuery),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(GqlQuery),
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = RunQueryRequest_FieldNumber_ProjectId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RunQueryRequest__storage_, projectId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RunQueryRequest class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:oneofs
                                    oneofCount:sizeof(oneofs) / sizeof(GPBMessageOneofDescription)
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RunQueryRequest__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void RunQueryRequest_ClearQueryTypeOneOfCase(RunQueryRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, 0);
}
#pragma mark - RunQueryResponse

@implementation RunQueryResponse

@dynamic hasBatch, batch;
@dynamic hasQuery, query;

typedef struct RunQueryResponse__storage_ {
  uint32_t _has_storage_[1];
  QueryResultBatch *batch;
  Query *query;
} RunQueryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "batch",
        .number = RunQueryResponse_FieldNumber_Batch,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RunQueryResponse__storage_, batch),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(QueryResultBatch),
        .fieldOptions = NULL,
      },
      {
        .name = "query",
        .number = RunQueryResponse_FieldNumber_Query,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RunQueryResponse__storage_, query),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Query),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RunQueryResponse class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RunQueryResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BeginTransactionRequest

@implementation BeginTransactionRequest

@dynamic projectId;

typedef struct BeginTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *projectId;
} BeginTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "projectId",
        .number = BeginTransactionRequest_FieldNumber_ProjectId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(BeginTransactionRequest__storage_, projectId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BeginTransactionRequest class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(BeginTransactionRequest__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BeginTransactionResponse

@implementation BeginTransactionResponse

@dynamic transaction;

typedef struct BeginTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *transaction;
} BeginTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .number = BeginTransactionResponse_FieldNumber_Transaction,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(BeginTransactionResponse__storage_, transaction),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BeginTransactionResponse class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(BeginTransactionResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RollbackRequest

@implementation RollbackRequest

@dynamic projectId;
@dynamic transaction;

typedef struct RollbackRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *transaction;
  NSString *projectId;
} RollbackRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .number = RollbackRequest_FieldNumber_Transaction,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(RollbackRequest__storage_, transaction),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = RollbackRequest_FieldNumber_ProjectId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RollbackRequest__storage_, projectId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RollbackRequest class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RollbackRequest__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RollbackResponse

@implementation RollbackResponse


typedef struct RollbackResponse__storage_ {
  uint32_t _has_storage_[0];
} RollbackResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RollbackResponse class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RollbackResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommitRequest

@implementation CommitRequest

@dynamic transactionSelectorOneOfCase;
@dynamic projectId;
@dynamic mode;
@dynamic transaction;
@dynamic mutationsArray, mutationsArray_Count;

typedef struct CommitRequest__storage_ {
  uint32_t _has_storage_[2];
  CommitRequest_Mode mode;
  NSData *transaction;
  NSMutableArray *mutationsArray;
  NSString *projectId;
} CommitRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageOneofDescription oneofs[] = {
      {
        .name = "transactionSelector",
        .index = -1,
      },
    };
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .number = CommitRequest_FieldNumber_Transaction,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(CommitRequest__storage_, transaction),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "mode",
        .number = CommitRequest_FieldNumber_Mode,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CommitRequest__storage_, mode),
        .defaultValue.valueEnum = CommitRequest_Mode_ModeUnspecified,
        .dataTypeSpecific.enumDescFunc = CommitRequest_Mode_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "mutationsArray",
        .number = CommitRequest_FieldNumber_MutationsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CommitRequest__storage_, mutationsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Mutation),
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = CommitRequest_FieldNumber_ProjectId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CommitRequest__storage_, projectId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = CommitRequest_Mode_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommitRequest class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:oneofs
                                    oneofCount:sizeof(oneofs) / sizeof(GPBMessageOneofDescription)
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CommitRequest__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CommitRequest_Mode_RawValue(CommitRequest *message) {
  GPBDescriptor *descriptor = [CommitRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CommitRequest_FieldNumber_Mode];
  return GPBGetMessageInt32Field(message, field);
}

void SetCommitRequest_Mode_RawValue(CommitRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [CommitRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CommitRequest_FieldNumber_Mode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void CommitRequest_ClearTransactionSelectorOneOfCase(CommitRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, 0);
}
#pragma mark - Enum CommitRequest_Mode

GPBEnumDescriptor *CommitRequest_Mode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "ModeUnspecified", .number = CommitRequest_Mode_ModeUnspecified },
      { .name = "Transactional", .number = CommitRequest_Mode_Transactional },
      { .name = "NonTransactional", .number = CommitRequest_Mode_NonTransactional },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CommitRequest_Mode)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CommitRequest_Mode_IsValidValue];
  }
  return descriptor;
}

BOOL CommitRequest_Mode_IsValidValue(int32_t value__) {
  switch (value__) {
    case CommitRequest_Mode_ModeUnspecified:
    case CommitRequest_Mode_Transactional:
    case CommitRequest_Mode_NonTransactional:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CommitResponse

@implementation CommitResponse

@dynamic mutationResultsArray, mutationResultsArray_Count;
@dynamic indexUpdates;

typedef struct CommitResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t indexUpdates;
  NSMutableArray *mutationResultsArray;
} CommitResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mutationResultsArray",
        .number = CommitResponse_FieldNumber_MutationResultsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CommitResponse__storage_, mutationResultsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(MutationResult),
        .fieldOptions = NULL,
      },
      {
        .name = "indexUpdates",
        .number = CommitResponse_FieldNumber_IndexUpdates,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(CommitResponse__storage_, indexUpdates),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommitResponse class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CommitResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AllocateIdsRequest

@implementation AllocateIdsRequest

@dynamic projectId;
@dynamic keysArray, keysArray_Count;

typedef struct AllocateIdsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keysArray;
  NSString *projectId;
} AllocateIdsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keysArray",
        .number = AllocateIdsRequest_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AllocateIdsRequest__storage_, keysArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = AllocateIdsRequest_FieldNumber_ProjectId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(AllocateIdsRequest__storage_, projectId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AllocateIdsRequest class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(AllocateIdsRequest__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AllocateIdsResponse

@implementation AllocateIdsResponse

@dynamic keysArray, keysArray_Count;

typedef struct AllocateIdsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keysArray;
} AllocateIdsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keysArray",
        .number = AllocateIdsResponse_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AllocateIdsResponse__storage_, keysArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AllocateIdsResponse class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(AllocateIdsResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Mutation

@implementation Mutation

@dynamic operationOneOfCase;
@dynamic insert;
@dynamic update;
@dynamic upsert;
@dynamic delete_p;

typedef struct Mutation__storage_ {
  uint32_t _has_storage_[2];
  Entity *insert;
  Entity *update;
  Entity *upsert;
  Key *delete_p;
} Mutation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageOneofDescription oneofs[] = {
      {
        .name = "operation",
        .index = -1,
      },
    };
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "insert",
        .number = Mutation_FieldNumber_Insert,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Mutation__storage_, insert),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Entity),
        .fieldOptions = NULL,
      },
      {
        .name = "update",
        .number = Mutation_FieldNumber_Update,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Mutation__storage_, update),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Entity),
        .fieldOptions = NULL,
      },
      {
        .name = "upsert",
        .number = Mutation_FieldNumber_Upsert,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Mutation__storage_, upsert),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Entity),
        .fieldOptions = NULL,
      },
      {
        .name = "delete_p",
        .number = Mutation_FieldNumber_Delete_p,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Mutation__storage_, delete_p),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Mutation class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:oneofs
                                    oneofCount:sizeof(oneofs) / sizeof(GPBMessageOneofDescription)
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Mutation__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Mutation_ClearOperationOneOfCase(Mutation *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, 0);
}
#pragma mark - MutationResult

@implementation MutationResult

@dynamic hasKey, key;

typedef struct MutationResult__storage_ {
  uint32_t _has_storage_[1];
  Key *key;
} MutationResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .number = MutationResult_FieldNumber_Key,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(MutationResult__storage_, key),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MutationResult class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(MutationResult__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReadOptions

@implementation ReadOptions

@dynamic consistencyTypeOneOfCase;
@dynamic readConsistency;
@dynamic transaction;

typedef struct ReadOptions__storage_ {
  uint32_t _has_storage_[2];
  ReadOptions_ReadConsistency readConsistency;
  NSData *transaction;
} ReadOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageOneofDescription oneofs[] = {
      {
        .name = "consistencyType",
        .index = -1,
      },
    };
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "readConsistency",
        .number = ReadOptions_FieldNumber_ReadConsistency,
        .hasIndex = -1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(ReadOptions__storage_, readConsistency),
        .defaultValue.valueEnum = ReadOptions_ReadConsistency_ReadConsistencyUnspecified,
        .dataTypeSpecific.enumDescFunc = ReadOptions_ReadConsistency_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "transaction",
        .number = ReadOptions_FieldNumber_Transaction,
        .hasIndex = -1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(ReadOptions__storage_, transaction),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = ReadOptions_ReadConsistency_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReadOptions class]
                                     rootClass:[DatastoreRoot class]
                                          file:DatastoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:oneofs
                                    oneofCount:sizeof(oneofs) / sizeof(GPBMessageOneofDescription)
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(ReadOptions__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ReadOptions_ReadConsistency_RawValue(ReadOptions *message) {
  GPBDescriptor *descriptor = [ReadOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ReadOptions_FieldNumber_ReadConsistency];
  return GPBGetMessageInt32Field(message, field);
}

void SetReadOptions_ReadConsistency_RawValue(ReadOptions *message, int32_t value) {
  GPBDescriptor *descriptor = [ReadOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ReadOptions_FieldNumber_ReadConsistency];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void ReadOptions_ClearConsistencyTypeOneOfCase(ReadOptions *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, 0);
}
#pragma mark - Enum ReadOptions_ReadConsistency

GPBEnumDescriptor *ReadOptions_ReadConsistency_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "ReadConsistencyUnspecified", .number = ReadOptions_ReadConsistency_ReadConsistencyUnspecified },
      { .name = "Strong", .number = ReadOptions_ReadConsistency_Strong },
      { .name = "Eventual", .number = ReadOptions_ReadConsistency_Eventual },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReadOptions_ReadConsistency)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:ReadOptions_ReadConsistency_IsValidValue];
  }
  return descriptor;
}

BOOL ReadOptions_ReadConsistency_IsValidValue(int32_t value__) {
  switch (value__) {
    case ReadOptions_ReadConsistency_ReadConsistencyUnspecified:
    case ReadOptions_ReadConsistency_Strong:
    case ReadOptions_ReadConsistency_Eventual:
      return YES;
    default:
      return NO;
  }
}


// @@protoc_insertion_point(global_scope)
