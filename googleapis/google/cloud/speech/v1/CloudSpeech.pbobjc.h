// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/speech/v1/cloud_speech.proto

#import "GPBProtocolBuffers.h"

#if GOOGLE_PROTOBUF_OBJC_GEN_VERSION != 30000
#error This file was generated by a different version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

CF_EXTERN_C_BEGIN

@class AudioRequest;
@class InitialRecognizeRequest;
@class Status;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum InitialRecognizeRequest_AudioEncoding

// Audio encoding of the data sent in the audio message.
typedef GPB_ENUM(InitialRecognizeRequest_AudioEncoding) {
  InitialRecognizeRequest_AudioEncoding_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  // Not specified. Will return result `INVALID_ARGUMENT`.
  InitialRecognizeRequest_AudioEncoding_EncodingUnspecified = 0,

  // Uncompressed 16-bit signed little-endian samples.
  // This is the simplest encoding format, useful for getting started.
  // However, because it is uncompressed, it is not recommended for deployed
  // clients.
  InitialRecognizeRequest_AudioEncoding_Linear16 = 1,

  // This is the recommended encoding format because it uses lossless
  // compression; therefore recognition accuracy is not compromised by a lossy
  // codec.
  //
  // The stream FLAC format is specified at:
  // http://flac.sourceforge.net/documentation.html.
  // Only 16-bit samples are supported.
  // Not all fields in STREAMINFO are supported.
  InitialRecognizeRequest_AudioEncoding_Flac = 2,

  // 8-bit samples that compand 14-bit audio samples using PCMU/mu-law.
  InitialRecognizeRequest_AudioEncoding_Mulaw = 3,

  // Adaptive Multi-Rate Narrowband codec. `sample_rate` must be 8000 Hz.
  InitialRecognizeRequest_AudioEncoding_Amr = 4,

  // Adaptive Multi-Rate Wideband codec. `sample_rate` must be 16000 Hz.
  InitialRecognizeRequest_AudioEncoding_AmrWb = 5,
};

GPBEnumDescriptor *InitialRecognizeRequest_AudioEncoding_EnumDescriptor(void);

BOOL InitialRecognizeRequest_AudioEncoding_IsValidValue(int32_t value);

#pragma mark - Enum RecognizeResponse_EndpointerEvent

// Indicates the type of endpointer event.
typedef GPB_ENUM(RecognizeResponse_EndpointerEvent) {
  RecognizeResponse_EndpointerEvent_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  // No endpointer event specified.
  RecognizeResponse_EndpointerEvent_EndpointerEventUnspecified = 0,

  // Speech has been detected in the audio stream.
  RecognizeResponse_EndpointerEvent_StartOfSpeech = 1,

  // Speech has ceased to be detected in the audio stream.
  RecognizeResponse_EndpointerEvent_EndOfSpeech = 2,

  // The end of the audio stream has been reached. and it is being processed.
  RecognizeResponse_EndpointerEvent_EndOfAudio = 3,

  // This event is only sent when continuous is `false`. It indicates that the
  // server has detected the end of the user's speech utterance and expects no
  // additional speech. Therefore, the server will not process additional
  // audio. The client should stop sending additional audio data.
  RecognizeResponse_EndpointerEvent_EndOfUtterance = 4,
};

GPBEnumDescriptor *RecognizeResponse_EndpointerEvent_EnumDescriptor(void);

BOOL RecognizeResponse_EndpointerEvent_IsValidValue(int32_t value);

#pragma mark - CloudSpeechRoot

@interface CloudSpeechRoot : GPBRootObject

// The base class provides:
//   + (GPBExtensionRegistry *)extensionRegistry;
// which is an GPBExtensionRegistry that includes all the extensions defined by
// this file and all files that it depends on.

@end

#pragma mark - RecognizeRequest

typedef GPB_ENUM(RecognizeRequest_FieldNumber) {
  RecognizeRequest_FieldNumber_InitialRequest = 1,
  RecognizeRequest_FieldNumber_AudioRequest = 2,
};

// `RecognizeRequest` is the only message type sent by the client.
//
// `NonStreamingRecognize` sends only one `RecognizeRequest` message and it
// must contain both an `initial_request` and an 'audio_request`.
//
// Streaming `Recognize` sends one or more `RecognizeRequest` messages. The
// first message must contain an `initial_request` and may contain an
// 'audio_request`. Any subsequent messages must not contain an
// `initial_request` and must contain an 'audio_request`.
@interface RecognizeRequest : GPBMessage

// The `initial_request` message provides information to the recognizer
// that specifies how to process the request.
//
// The first `RecognizeRequest` message must contain an `initial_request`.
// Any subsequent `RecognizeRequest` messages must not contain an
// `initial_request`.
@property(nonatomic, readwrite) BOOL hasInitialRequest;
@property(nonatomic, readwrite, strong, null_resettable) InitialRecognizeRequest *initialRequest;

// The audio data to be recognized. For `NonStreamingRecognize`, all the
// audio data must be contained in the first (and only) `RecognizeRequest`
//  message. For streaming `Recognize`, sequential chunks of audio data are
// sent in sequential `RecognizeRequest` messages.
@property(nonatomic, readwrite) BOOL hasAudioRequest;
@property(nonatomic, readwrite, strong, null_resettable) AudioRequest *audioRequest;

@end

#pragma mark - InitialRecognizeRequest

typedef GPB_ENUM(InitialRecognizeRequest_FieldNumber) {
  InitialRecognizeRequest_FieldNumber_Encoding = 1,
  InitialRecognizeRequest_FieldNumber_SampleRate = 2,
  InitialRecognizeRequest_FieldNumber_LanguageCode = 3,
  InitialRecognizeRequest_FieldNumber_MaxAlternatives = 4,
  InitialRecognizeRequest_FieldNumber_ProfanityFilter = 5,
  InitialRecognizeRequest_FieldNumber_Continuous = 6,
  InitialRecognizeRequest_FieldNumber_InterimResults = 7,
  InitialRecognizeRequest_FieldNumber_EnableEndpointerEvents = 8,
};

// The `InitialRecognizeRequest` message provides information to the recognizer
// that specifies how to process the request.
@interface InitialRecognizeRequest : GPBMessage

// [Required] Encoding of audio data sent in all `AudioRequest` messages.
@property(nonatomic, readwrite) InitialRecognizeRequest_AudioEncoding encoding;

// [Required] Sample rate in Hertz of the audio data sent in all
// AudioRequest messages.
// 16000 is optimal. Valid values are: 8000-48000.
@property(nonatomic, readwrite) int32_t sampleRate;

// [Optional] The language of the supplied audio as a BCP-47 language tag.
// Example: "en-GB"  https://www.rfc-editor.org/rfc/bcp/bcp47.txt
// If omitted, defaults to "en-US".
@property(nonatomic, readwrite, copy, null_resettable) NSString *languageCode;

// [Optional] Maximum number of recognition hypotheses to be returned.
// Specifically, the maximum number of `SpeechRecognitionAlternative` messages
// within each `SpeechRecognitionResult`.
// The server may return fewer than `max_alternatives`.
// Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
// `1`. If omitted, defaults to `1`.
@property(nonatomic, readwrite) int32_t maxAlternatives;

// [Optional] If set to `true`, the server will attempt to filter out
// profanities, replacing all but the initial character in each filtered word
// with asterisks, e.g. "f***". If set to `false` or omitted, profanities
// won't be filtered out.
// Note that profanity filtering is not implemented for all languages.
// If the language is not supported, this setting has no effect.
@property(nonatomic, readwrite) BOOL profanityFilter;

// [Optional] If `false` or omitted, the recognizer will detect a single
// spoken utterance, and it will cease recognition when the user stops
// speaking. If `enable_endpointer_events` is `true`, it will return
// `END_OF_UTTERANCE` when it detects that the user has stopped speaking.
// In all cases, it will return no more than one `SpeechRecognitionResult`,
// and set the `is_final` flag to `true`.
//
// If `true`, the recognizer will continue recognition (even if the user
// pauses speaking) until the client sends an `end_of_data` message or when
// the maximum time limit has been reached. Multiple
// `SpeechRecognitionResult`s with the `is_final` flag set to `true` may be
// returned to indicate that the recognizer will not return any further
// hypotheses for this portion of the transcript.
@property(nonatomic, readwrite) BOOL continuous;

// [Optional] If this parameter is `true`, interim results may be returned as
// they become available.
// If `false` or omitted, only `is_final=true` result(s) are returned.
@property(nonatomic, readwrite) BOOL interimResults;

// [Optional] If this parameter is `true`, `EndpointerEvents` may be returned
// as they become available.
// If `false` or omitted, no `EndpointerEvents` are returned.
@property(nonatomic, readwrite) BOOL enableEndpointerEvents;

@end

int32_t InitialRecognizeRequest_Encoding_RawValue(InitialRecognizeRequest *message);
void SetInitialRecognizeRequest_Encoding_RawValue(InitialRecognizeRequest *message, int32_t value);

#pragma mark - AudioRequest

typedef GPB_ENUM(AudioRequest_FieldNumber) {
  AudioRequest_FieldNumber_Content = 1,
};

// Contains audio data in the format specified in the `InitialRecognizeRequest`.
@interface AudioRequest : GPBMessage

// [Required] The audio data bytes encoded as specified in
// `InitialRecognizeRequest`.
@property(nonatomic, readwrite, copy, null_resettable) NSData *content;

@end

#pragma mark - NonStreamingRecognizeResponse

typedef GPB_ENUM(NonStreamingRecognizeResponse_FieldNumber) {
  NonStreamingRecognizeResponse_FieldNumber_ResponsesArray = 1,
};

// `NonStreamingRecognizeResponse` is the only message returned to the client by
// `NonStreamingRecognize`. It contains the result as zero or more sequential
// `RecognizeResponse` messages.
//
// Note that streaming `Recognize` will also return multiple `RecognizeResponse`
// messages, but each message is individually streamed.
@interface NonStreamingRecognizeResponse : GPBMessage

// [Output-only] Sequential list of messages returned by the recognizer.
// |responsesArray| contains |RecognizeResponse|
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray *responsesArray;
@property(nonatomic, readonly) NSUInteger responsesArray_Count;

@end

#pragma mark - RecognizeResponse

typedef GPB_ENUM(RecognizeResponse_FieldNumber) {
  RecognizeResponse_FieldNumber_Error = 1,
  RecognizeResponse_FieldNumber_ResultsArray = 2,
  RecognizeResponse_FieldNumber_ResultIndex = 3,
  RecognizeResponse_FieldNumber_Endpoint = 4,
};

// `RecognizeResponse` is the only message type returned to the client.
@interface RecognizeResponse : GPBMessage

// [Output-only] If set, returns a [google.rpc.Status][] message that
// specifies the error for the operation.
@property(nonatomic, readwrite) BOOL hasError;
@property(nonatomic, readwrite, strong, null_resettable) Status *error;

// [Output-only] For `continuous=false`, this repeated list contains zero or
// one result that corresponds to all of the audio processed so far. For
// `continuous=true`, this repeated list contains zero or more results that
// correspond to consecutive portions of the audio being processed.
// In both cases, contains zero or one `is_final=true` result (the newly
// settled portion), followed by zero or more `is_final=false` results.
// |resultsArray| contains |SpeechRecognitionResult|
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray *resultsArray;
@property(nonatomic, readonly) NSUInteger resultsArray_Count;

// [Output-only] Indicates the lowest index in the `results` array that has
// changed. The repeated `SpeechRecognitionResult` results overwrite past
// results at this index and higher.
@property(nonatomic, readwrite) int32_t resultIndex;

// [Output-only] Indicates the type of endpointer event.
@property(nonatomic, readwrite) RecognizeResponse_EndpointerEvent endpoint;

@end

int32_t RecognizeResponse_Endpoint_RawValue(RecognizeResponse *message);
void SetRecognizeResponse_Endpoint_RawValue(RecognizeResponse *message, int32_t value);

#pragma mark - SpeechRecognitionResult

typedef GPB_ENUM(SpeechRecognitionResult_FieldNumber) {
  SpeechRecognitionResult_FieldNumber_AlternativesArray = 1,
  SpeechRecognitionResult_FieldNumber_IsFinal = 2,
  SpeechRecognitionResult_FieldNumber_Stability = 3,
};

// A speech recognition result corresponding to a portion of the audio.
@interface SpeechRecognitionResult : GPBMessage

// [Output-only] May contain one or more recognition hypotheses (up to the
// maximum specified in `max_alternatives`).
// |alternativesArray| contains |SpeechRecognitionAlternative|
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray *alternativesArray;
@property(nonatomic, readonly) NSUInteger alternativesArray_Count;

// [Output-only] Set `true` if this is the final time the speech service will
// return this particular `SpeechRecognitionResult`. If `false`, this
// represents an interim result that may change.
@property(nonatomic, readwrite) BOOL isFinal;

// [Output-only] An estimate of the probability that the recognizer will not
// change its guess about this interim result. Values range from 0.0
// (completely unstable) to 1.0 (completely stable). Note that this is not the
// same as `confidence`, which estimates the probability that a recognition
// result is correct.
// This field is only provided for interim results (`is_final=false`).
// The default of 0.0 is a sentinel value indicating stability was not set.
@property(nonatomic, readwrite) float stability;

@end

#pragma mark - SpeechRecognitionAlternative

typedef GPB_ENUM(SpeechRecognitionAlternative_FieldNumber) {
  SpeechRecognitionAlternative_FieldNumber_Transcript = 1,
  SpeechRecognitionAlternative_FieldNumber_Confidence = 2,
};

// Alternative hypotheses (a.k.a. n-best list).
@interface SpeechRecognitionAlternative : GPBMessage

// [Output-only] Transcript text representing the words that the user spoke.
@property(nonatomic, readwrite, copy, null_resettable) NSString *transcript;

// [Output-only] The confidence estimate between 0.0 and 1.0. A higher number
// means the system is more confident that the recognition is correct.
// This field is typically provided only for the top hypothesis. and only for
// `is_final=true` results.
// The default of 0.0 is a sentinel value indicating confidence was not set.
@property(nonatomic, readwrite) float confidence;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

// @@protoc_insertion_point(global_scope)
