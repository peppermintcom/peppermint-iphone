// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/vision/v1/image_annotator.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "google/cloud/vision/v1/ImageAnnotator.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
#import "google/cloud/vision/v1/Geometry.pbobjc.h"
#import "google/rpc/Status.pbobjc.h"
#import "google/type/Color.pbobjc.h"
#import "google/type/Latlng.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - ImageAnnotatorRoot

@implementation ImageAnnotatorRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
    [registry addExtensions:[GeometryRoot extensionRegistry]];
    [registry addExtensions:[StatusRoot extensionRegistry]];
    [registry addExtensions:[ColorRoot extensionRegistry]];
    [registry addExtensions:[LatlngRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - ImageAnnotatorRoot_FileDescriptor

static GPBFileDescriptor *ImageAnnotatorRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.cloud.vision.v1"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Likelihood

GPBEnumDescriptor *Likelihood_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Unknown", .number = Likelihood_Unknown },
      { .name = "VeryUnlikely", .number = Likelihood_VeryUnlikely },
      { .name = "Unlikely", .number = Likelihood_Unlikely },
      { .name = "Possible", .number = Likelihood_Possible },
      { .name = "Likely", .number = Likelihood_Likely },
      { .name = "VeryLikely", .number = Likelihood_VeryLikely },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Likelihood)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Likelihood_IsValidValue];
  }
  return descriptor;
}

BOOL Likelihood_IsValidValue(int32_t value__) {
  switch (value__) {
    case Likelihood_Unknown:
    case Likelihood_VeryUnlikely:
    case Likelihood_Unlikely:
    case Likelihood_Possible:
    case Likelihood_Likely:
    case Likelihood_VeryLikely:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Feature

@implementation Feature

@dynamic type;
@dynamic maxResults;

typedef struct Feature__storage_ {
  uint32_t _has_storage_[1];
  Feature_Type type;
  int32_t maxResults;
} Feature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .number = Feature_FieldNumber_Type,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Feature__storage_, type),
        .defaultValue.valueEnum = Feature_Type_TypeUnspecified,
        .dataTypeSpecific.enumDescFunc = Feature_Type_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "maxResults",
        .number = Feature_FieldNumber_MaxResults,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
        .offset = offsetof(Feature__storage_, maxResults),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = Feature_Type_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Feature class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Feature__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Feature_Type_RawValue(Feature *message) {
  GPBDescriptor *descriptor = [Feature descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Feature_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetFeature_Type_RawValue(Feature *message, int32_t value) {
  GPBDescriptor *descriptor = [Feature descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Feature_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Feature_Type

GPBEnumDescriptor *Feature_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "TypeUnspecified", .number = Feature_Type_TypeUnspecified },
      { .name = "FaceDetection", .number = Feature_Type_FaceDetection },
      { .name = "LandmarkDetection", .number = Feature_Type_LandmarkDetection },
      { .name = "LogoDetection", .number = Feature_Type_LogoDetection },
      { .name = "LabelDetection", .number = Feature_Type_LabelDetection },
      { .name = "TextDetection", .number = Feature_Type_TextDetection },
      { .name = "SafeSearchDetection", .number = Feature_Type_SafeSearchDetection },
      { .name = "ImageProperties", .number = Feature_Type_ImageProperties },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Feature_Type)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Feature_Type_IsValidValue];
  }
  return descriptor;
}

BOOL Feature_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Feature_Type_TypeUnspecified:
    case Feature_Type_FaceDetection:
    case Feature_Type_LandmarkDetection:
    case Feature_Type_LogoDetection:
    case Feature_Type_LabelDetection:
    case Feature_Type_TextDetection:
    case Feature_Type_SafeSearchDetection:
    case Feature_Type_ImageProperties:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ImageSource

@implementation ImageSource

@dynamic gcsImageUri;

typedef struct ImageSource__storage_ {
  uint32_t _has_storage_[1];
  NSString *gcsImageUri;
} ImageSource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gcsImageUri",
        .number = ImageSource_FieldNumber_GcsImageUri,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(ImageSource__storage_, gcsImageUri),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageSource class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(ImageSource__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Image

@implementation Image

@dynamic content;
@dynamic hasSource, source;

typedef struct Image__storage_ {
  uint32_t _has_storage_[1];
  NSData *content;
  ImageSource *source;
} Image__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .number = Image_FieldNumber_Content,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(Image__storage_, content),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
      #if GPBOBJC_INCLUDE_FIELD_OPTIONS
        .fieldOptions = "\000\000\000\002\010\001",
      #else
        .fieldOptions = NULL,
      #endif  // GPBOBJC_INCLUDE_FIELD_OPTIONS
      },
      {
        .name = "source",
        .number = Image_FieldNumber_Source,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Image__storage_, source),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ImageSource),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Image class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Image__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FaceAnnotation

@implementation FaceAnnotation

@dynamic hasBoundingPoly, boundingPoly;
@dynamic hasFdBoundingPoly, fdBoundingPoly;
@dynamic landmarksArray, landmarksArray_Count;
@dynamic rollAngle;
@dynamic panAngle;
@dynamic tiltAngle;
@dynamic detectionConfidence;
@dynamic landmarkingConfidence;
@dynamic joyLikelihood;
@dynamic sorrowLikelihood;
@dynamic angerLikelihood;
@dynamic surpriseLikelihood;
@dynamic underExposedLikelihood;
@dynamic blurredLikelihood;
@dynamic headwearLikelihood;

typedef struct FaceAnnotation__storage_ {
  uint32_t _has_storage_[1];
  float rollAngle;
  float panAngle;
  float tiltAngle;
  float detectionConfidence;
  float landmarkingConfidence;
  Likelihood joyLikelihood;
  Likelihood sorrowLikelihood;
  Likelihood angerLikelihood;
  Likelihood surpriseLikelihood;
  Likelihood underExposedLikelihood;
  Likelihood blurredLikelihood;
  Likelihood headwearLikelihood;
  BoundingPoly *boundingPoly;
  BoundingPoly *fdBoundingPoly;
  NSMutableArray *landmarksArray;
} FaceAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boundingPoly",
        .number = FaceAnnotation_FieldNumber_BoundingPoly,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FaceAnnotation__storage_, boundingPoly),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(BoundingPoly),
        .fieldOptions = NULL,
      },
      {
        .name = "fdBoundingPoly",
        .number = FaceAnnotation_FieldNumber_FdBoundingPoly,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FaceAnnotation__storage_, fdBoundingPoly),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(BoundingPoly),
        .fieldOptions = NULL,
      },
      {
        .name = "landmarksArray",
        .number = FaceAnnotation_FieldNumber_LandmarksArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FaceAnnotation__storage_, landmarksArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(FaceAnnotation_Landmark),
        .fieldOptions = NULL,
      },
      {
        .name = "rollAngle",
        .number = FaceAnnotation_FieldNumber_RollAngle,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(FaceAnnotation__storage_, rollAngle),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "panAngle",
        .number = FaceAnnotation_FieldNumber_PanAngle,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(FaceAnnotation__storage_, panAngle),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "tiltAngle",
        .number = FaceAnnotation_FieldNumber_TiltAngle,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(FaceAnnotation__storage_, tiltAngle),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "detectionConfidence",
        .number = FaceAnnotation_FieldNumber_DetectionConfidence,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(FaceAnnotation__storage_, detectionConfidence),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "landmarkingConfidence",
        .number = FaceAnnotation_FieldNumber_LandmarkingConfidence,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(FaceAnnotation__storage_, landmarkingConfidence),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "joyLikelihood",
        .number = FaceAnnotation_FieldNumber_JoyLikelihood,
        .hasIndex = 8,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FaceAnnotation__storage_, joyLikelihood),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "sorrowLikelihood",
        .number = FaceAnnotation_FieldNumber_SorrowLikelihood,
        .hasIndex = 9,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FaceAnnotation__storage_, sorrowLikelihood),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "angerLikelihood",
        .number = FaceAnnotation_FieldNumber_AngerLikelihood,
        .hasIndex = 10,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FaceAnnotation__storage_, angerLikelihood),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "surpriseLikelihood",
        .number = FaceAnnotation_FieldNumber_SurpriseLikelihood,
        .hasIndex = 11,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FaceAnnotation__storage_, surpriseLikelihood),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "underExposedLikelihood",
        .number = FaceAnnotation_FieldNumber_UnderExposedLikelihood,
        .hasIndex = 12,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FaceAnnotation__storage_, underExposedLikelihood),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "blurredLikelihood",
        .number = FaceAnnotation_FieldNumber_BlurredLikelihood,
        .hasIndex = 13,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FaceAnnotation__storage_, blurredLikelihood),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "headwearLikelihood",
        .number = FaceAnnotation_FieldNumber_HeadwearLikelihood,
        .hasIndex = 14,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FaceAnnotation__storage_, headwearLikelihood),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceAnnotation class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(FaceAnnotation__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FaceAnnotation_JoyLikelihood_RawValue(FaceAnnotation *message) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_JoyLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceAnnotation_JoyLikelihood_RawValue(FaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_JoyLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FaceAnnotation_SorrowLikelihood_RawValue(FaceAnnotation *message) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_SorrowLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceAnnotation_SorrowLikelihood_RawValue(FaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_SorrowLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FaceAnnotation_AngerLikelihood_RawValue(FaceAnnotation *message) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_AngerLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceAnnotation_AngerLikelihood_RawValue(FaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_AngerLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FaceAnnotation_SurpriseLikelihood_RawValue(FaceAnnotation *message) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_SurpriseLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceAnnotation_SurpriseLikelihood_RawValue(FaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_SurpriseLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FaceAnnotation_UnderExposedLikelihood_RawValue(FaceAnnotation *message) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_UnderExposedLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceAnnotation_UnderExposedLikelihood_RawValue(FaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_UnderExposedLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FaceAnnotation_BlurredLikelihood_RawValue(FaceAnnotation *message) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_BlurredLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceAnnotation_BlurredLikelihood_RawValue(FaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_BlurredLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FaceAnnotation_HeadwearLikelihood_RawValue(FaceAnnotation *message) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_HeadwearLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceAnnotation_HeadwearLikelihood_RawValue(FaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_FieldNumber_HeadwearLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - FaceAnnotation_Landmark

@implementation FaceAnnotation_Landmark

@dynamic type;
@dynamic hasPosition, position;

typedef struct FaceAnnotation_Landmark__storage_ {
  uint32_t _has_storage_[1];
  FaceAnnotation_Landmark_Type type;
  Position *position;
} FaceAnnotation_Landmark__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .number = FaceAnnotation_Landmark_FieldNumber_Type,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FaceAnnotation_Landmark__storage_, type),
        .defaultValue.valueEnum = FaceAnnotation_Landmark_Type_UnknownLandmark,
        .dataTypeSpecific.enumDescFunc = FaceAnnotation_Landmark_Type_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "position",
        .number = FaceAnnotation_Landmark_FieldNumber_Position,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FaceAnnotation_Landmark__storage_, position),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Position),
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = FaceAnnotation_Landmark_Type_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceAnnotation_Landmark class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(FaceAnnotation_Landmark__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FaceAnnotation_Landmark_Type_RawValue(FaceAnnotation_Landmark *message) {
  GPBDescriptor *descriptor = [FaceAnnotation_Landmark descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_Landmark_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceAnnotation_Landmark_Type_RawValue(FaceAnnotation_Landmark *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceAnnotation_Landmark descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceAnnotation_Landmark_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum FaceAnnotation_Landmark_Type

GPBEnumDescriptor *FaceAnnotation_Landmark_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "UnknownLandmark", .number = FaceAnnotation_Landmark_Type_UnknownLandmark },
      { .name = "LeftEye", .number = FaceAnnotation_Landmark_Type_LeftEye },
      { .name = "RightEye", .number = FaceAnnotation_Landmark_Type_RightEye },
      { .name = "LeftOfLeftEyebrow", .number = FaceAnnotation_Landmark_Type_LeftOfLeftEyebrow },
      { .name = "RightOfLeftEyebrow", .number = FaceAnnotation_Landmark_Type_RightOfLeftEyebrow },
      { .name = "LeftOfRightEyebrow", .number = FaceAnnotation_Landmark_Type_LeftOfRightEyebrow },
      { .name = "RightOfRightEyebrow", .number = FaceAnnotation_Landmark_Type_RightOfRightEyebrow },
      { .name = "MidpointBetweenEyes", .number = FaceAnnotation_Landmark_Type_MidpointBetweenEyes },
      { .name = "NoseTip", .number = FaceAnnotation_Landmark_Type_NoseTip },
      { .name = "UpperLip", .number = FaceAnnotation_Landmark_Type_UpperLip },
      { .name = "LowerLip", .number = FaceAnnotation_Landmark_Type_LowerLip },
      { .name = "MouthLeft", .number = FaceAnnotation_Landmark_Type_MouthLeft },
      { .name = "MouthRight", .number = FaceAnnotation_Landmark_Type_MouthRight },
      { .name = "MouthCenter", .number = FaceAnnotation_Landmark_Type_MouthCenter },
      { .name = "NoseBottomRight", .number = FaceAnnotation_Landmark_Type_NoseBottomRight },
      { .name = "NoseBottomLeft", .number = FaceAnnotation_Landmark_Type_NoseBottomLeft },
      { .name = "NoseBottomCenter", .number = FaceAnnotation_Landmark_Type_NoseBottomCenter },
      { .name = "LeftEyeTopBoundary", .number = FaceAnnotation_Landmark_Type_LeftEyeTopBoundary },
      { .name = "LeftEyeRightCorner", .number = FaceAnnotation_Landmark_Type_LeftEyeRightCorner },
      { .name = "LeftEyeBottomBoundary", .number = FaceAnnotation_Landmark_Type_LeftEyeBottomBoundary },
      { .name = "LeftEyeLeftCorner", .number = FaceAnnotation_Landmark_Type_LeftEyeLeftCorner },
      { .name = "RightEyeTopBoundary", .number = FaceAnnotation_Landmark_Type_RightEyeTopBoundary },
      { .name = "RightEyeRightCorner", .number = FaceAnnotation_Landmark_Type_RightEyeRightCorner },
      { .name = "RightEyeBottomBoundary", .number = FaceAnnotation_Landmark_Type_RightEyeBottomBoundary },
      { .name = "RightEyeLeftCorner", .number = FaceAnnotation_Landmark_Type_RightEyeLeftCorner },
      { .name = "LeftEyebrowUpperMidpoint", .number = FaceAnnotation_Landmark_Type_LeftEyebrowUpperMidpoint },
      { .name = "RightEyebrowUpperMidpoint", .number = FaceAnnotation_Landmark_Type_RightEyebrowUpperMidpoint },
      { .name = "LeftEarTragion", .number = FaceAnnotation_Landmark_Type_LeftEarTragion },
      { .name = "RightEarTragion", .number = FaceAnnotation_Landmark_Type_RightEarTragion },
      { .name = "LeftEyePupil", .number = FaceAnnotation_Landmark_Type_LeftEyePupil },
      { .name = "RightEyePupil", .number = FaceAnnotation_Landmark_Type_RightEyePupil },
      { .name = "ForeheadGlabella", .number = FaceAnnotation_Landmark_Type_ForeheadGlabella },
      { .name = "ChinGnathion", .number = FaceAnnotation_Landmark_Type_ChinGnathion },
      { .name = "ChinLeftGonion", .number = FaceAnnotation_Landmark_Type_ChinLeftGonion },
      { .name = "ChinRightGonion", .number = FaceAnnotation_Landmark_Type_ChinRightGonion },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FaceAnnotation_Landmark_Type)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:FaceAnnotation_Landmark_Type_IsValidValue];
  }
  return descriptor;
}

BOOL FaceAnnotation_Landmark_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case FaceAnnotation_Landmark_Type_UnknownLandmark:
    case FaceAnnotation_Landmark_Type_LeftEye:
    case FaceAnnotation_Landmark_Type_RightEye:
    case FaceAnnotation_Landmark_Type_LeftOfLeftEyebrow:
    case FaceAnnotation_Landmark_Type_RightOfLeftEyebrow:
    case FaceAnnotation_Landmark_Type_LeftOfRightEyebrow:
    case FaceAnnotation_Landmark_Type_RightOfRightEyebrow:
    case FaceAnnotation_Landmark_Type_MidpointBetweenEyes:
    case FaceAnnotation_Landmark_Type_NoseTip:
    case FaceAnnotation_Landmark_Type_UpperLip:
    case FaceAnnotation_Landmark_Type_LowerLip:
    case FaceAnnotation_Landmark_Type_MouthLeft:
    case FaceAnnotation_Landmark_Type_MouthRight:
    case FaceAnnotation_Landmark_Type_MouthCenter:
    case FaceAnnotation_Landmark_Type_NoseBottomRight:
    case FaceAnnotation_Landmark_Type_NoseBottomLeft:
    case FaceAnnotation_Landmark_Type_NoseBottomCenter:
    case FaceAnnotation_Landmark_Type_LeftEyeTopBoundary:
    case FaceAnnotation_Landmark_Type_LeftEyeRightCorner:
    case FaceAnnotation_Landmark_Type_LeftEyeBottomBoundary:
    case FaceAnnotation_Landmark_Type_LeftEyeLeftCorner:
    case FaceAnnotation_Landmark_Type_RightEyeTopBoundary:
    case FaceAnnotation_Landmark_Type_RightEyeRightCorner:
    case FaceAnnotation_Landmark_Type_RightEyeBottomBoundary:
    case FaceAnnotation_Landmark_Type_RightEyeLeftCorner:
    case FaceAnnotation_Landmark_Type_LeftEyebrowUpperMidpoint:
    case FaceAnnotation_Landmark_Type_RightEyebrowUpperMidpoint:
    case FaceAnnotation_Landmark_Type_LeftEarTragion:
    case FaceAnnotation_Landmark_Type_RightEarTragion:
    case FaceAnnotation_Landmark_Type_LeftEyePupil:
    case FaceAnnotation_Landmark_Type_RightEyePupil:
    case FaceAnnotation_Landmark_Type_ForeheadGlabella:
    case FaceAnnotation_Landmark_Type_ChinGnathion:
    case FaceAnnotation_Landmark_Type_ChinLeftGonion:
    case FaceAnnotation_Landmark_Type_ChinRightGonion:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - LocationInfo

@implementation LocationInfo

@dynamic hasLatLng, latLng;

typedef struct LocationInfo__storage_ {
  uint32_t _has_storage_[1];
  LatLng *latLng;
} LocationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latLng",
        .number = LocationInfo_FieldNumber_LatLng,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LocationInfo__storage_, latLng),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(LatLng),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocationInfo class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LocationInfo__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Property

@implementation Property

@dynamic name;
@dynamic value;

typedef struct Property__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
} Property__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .number = Property_FieldNumber_Name,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Property__storage_, name),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "value",
        .number = Property_FieldNumber_Value,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Property__storage_, value),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Property class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Property__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EntityAnnotation

@implementation EntityAnnotation

@dynamic mid;
@dynamic locale;
@dynamic description_p;
@dynamic score;
@dynamic confidence;
@dynamic topicality;
@dynamic hasBoundingPoly, boundingPoly;
@dynamic locationsArray, locationsArray_Count;
@dynamic propertiesArray, propertiesArray_Count;

typedef struct EntityAnnotation__storage_ {
  uint32_t _has_storage_[1];
  float score;
  float confidence;
  float topicality;
  NSString *mid;
  NSString *locale;
  NSString *description_p;
  BoundingPoly *boundingPoly;
  NSMutableArray *locationsArray;
  NSMutableArray *propertiesArray;
} EntityAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .number = EntityAnnotation_FieldNumber_Mid,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(EntityAnnotation__storage_, mid),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "locale",
        .number = EntityAnnotation_FieldNumber_Locale,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(EntityAnnotation__storage_, locale),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "description_p",
        .number = EntityAnnotation_FieldNumber_Description_p,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(EntityAnnotation__storage_, description_p),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "score",
        .number = EntityAnnotation_FieldNumber_Score,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(EntityAnnotation__storage_, score),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "confidence",
        .number = EntityAnnotation_FieldNumber_Confidence,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(EntityAnnotation__storage_, confidence),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "topicality",
        .number = EntityAnnotation_FieldNumber_Topicality,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(EntityAnnotation__storage_, topicality),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "boundingPoly",
        .number = EntityAnnotation_FieldNumber_BoundingPoly,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(EntityAnnotation__storage_, boundingPoly),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(BoundingPoly),
        .fieldOptions = NULL,
      },
      {
        .name = "locationsArray",
        .number = EntityAnnotation_FieldNumber_LocationsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(EntityAnnotation__storage_, locationsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(LocationInfo),
        .fieldOptions = NULL,
      },
      {
        .name = "propertiesArray",
        .number = EntityAnnotation_FieldNumber_PropertiesArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(EntityAnnotation__storage_, propertiesArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Property),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EntityAnnotation class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(EntityAnnotation__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SafeSearchAnnotation

@implementation SafeSearchAnnotation

@dynamic adult;
@dynamic spoof;
@dynamic medical;
@dynamic violence;
@dynamic adultScore;
@dynamic spoofScore;
@dynamic medicalScore;
@dynamic violenceScore;

typedef struct SafeSearchAnnotation__storage_ {
  uint32_t _has_storage_[1];
  Likelihood adult;
  Likelihood spoof;
  Likelihood medical;
  Likelihood violence;
  float adultScore;
  float spoofScore;
  float medicalScore;
  float violenceScore;
} SafeSearchAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "adult",
        .number = SafeSearchAnnotation_FieldNumber_Adult,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(SafeSearchAnnotation__storage_, adult),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "spoof",
        .number = SafeSearchAnnotation_FieldNumber_Spoof,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(SafeSearchAnnotation__storage_, spoof),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "medical",
        .number = SafeSearchAnnotation_FieldNumber_Medical,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(SafeSearchAnnotation__storage_, medical),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "violence",
        .number = SafeSearchAnnotation_FieldNumber_Violence,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(SafeSearchAnnotation__storage_, violence),
        .defaultValue.valueEnum = Likelihood_Unknown,
        .dataTypeSpecific.enumDescFunc = Likelihood_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "adultScore",
        .number = SafeSearchAnnotation_FieldNumber_AdultScore,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(SafeSearchAnnotation__storage_, adultScore),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "spoofScore",
        .number = SafeSearchAnnotation_FieldNumber_SpoofScore,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(SafeSearchAnnotation__storage_, spoofScore),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "medicalScore",
        .number = SafeSearchAnnotation_FieldNumber_MedicalScore,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(SafeSearchAnnotation__storage_, medicalScore),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "violenceScore",
        .number = SafeSearchAnnotation_FieldNumber_ViolenceScore,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(SafeSearchAnnotation__storage_, violenceScore),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SafeSearchAnnotation class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(SafeSearchAnnotation__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SafeSearchAnnotation_Adult_RawValue(SafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [SafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SafeSearchAnnotation_FieldNumber_Adult];
  return GPBGetMessageInt32Field(message, field);
}

void SetSafeSearchAnnotation_Adult_RawValue(SafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [SafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SafeSearchAnnotation_FieldNumber_Adult];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SafeSearchAnnotation_Spoof_RawValue(SafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [SafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SafeSearchAnnotation_FieldNumber_Spoof];
  return GPBGetMessageInt32Field(message, field);
}

void SetSafeSearchAnnotation_Spoof_RawValue(SafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [SafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SafeSearchAnnotation_FieldNumber_Spoof];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SafeSearchAnnotation_Medical_RawValue(SafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [SafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SafeSearchAnnotation_FieldNumber_Medical];
  return GPBGetMessageInt32Field(message, field);
}

void SetSafeSearchAnnotation_Medical_RawValue(SafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [SafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SafeSearchAnnotation_FieldNumber_Medical];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SafeSearchAnnotation_Violence_RawValue(SafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [SafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SafeSearchAnnotation_FieldNumber_Violence];
  return GPBGetMessageInt32Field(message, field);
}

void SetSafeSearchAnnotation_Violence_RawValue(SafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [SafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SafeSearchAnnotation_FieldNumber_Violence];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - LatLongRect

@implementation LatLongRect

@dynamic hasMinLatLng, minLatLng;
@dynamic hasMaxLatLng, maxLatLng;

typedef struct LatLongRect__storage_ {
  uint32_t _has_storage_[1];
  LatLng *minLatLng;
  LatLng *maxLatLng;
} LatLongRect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minLatLng",
        .number = LatLongRect_FieldNumber_MinLatLng,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LatLongRect__storage_, minLatLng),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(LatLng),
        .fieldOptions = NULL,
      },
      {
        .name = "maxLatLng",
        .number = LatLongRect_FieldNumber_MaxLatLng,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LatLongRect__storage_, maxLatLng),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(LatLng),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LatLongRect class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LatLongRect__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ColorInfo

@implementation ColorInfo

@dynamic hasColor, color;
@dynamic score;
@dynamic pixelFraction;

typedef struct ColorInfo__storage_ {
  uint32_t _has_storage_[1];
  float score;
  float pixelFraction;
  Color *color;
} ColorInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "color",
        .number = ColorInfo_FieldNumber_Color,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(ColorInfo__storage_, color),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Color),
        .fieldOptions = NULL,
      },
      {
        .name = "score",
        .number = ColorInfo_FieldNumber_Score,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(ColorInfo__storage_, score),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "pixelFraction",
        .number = ColorInfo_FieldNumber_PixelFraction,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
        .offset = offsetof(ColorInfo__storage_, pixelFraction),
        .defaultValue.valueFloat = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ColorInfo class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(ColorInfo__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DominantColorsAnnotation

@implementation DominantColorsAnnotation

@dynamic colorsArray, colorsArray_Count;

typedef struct DominantColorsAnnotation__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *colorsArray;
} DominantColorsAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "colorsArray",
        .number = DominantColorsAnnotation_FieldNumber_ColorsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(DominantColorsAnnotation__storage_, colorsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ColorInfo),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DominantColorsAnnotation class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(DominantColorsAnnotation__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ImageProperties

@implementation ImageProperties

@dynamic hasDominantColors, dominantColors;

typedef struct ImageProperties__storage_ {
  uint32_t _has_storage_[1];
  DominantColorsAnnotation *dominantColors;
} ImageProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dominantColors",
        .number = ImageProperties_FieldNumber_DominantColors,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(ImageProperties__storage_, dominantColors),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(DominantColorsAnnotation),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageProperties class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(ImageProperties__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ImageContext

@implementation ImageContext

@dynamic hasLatLongRect, latLongRect;
@dynamic languageHintsArray, languageHintsArray_Count;

typedef struct ImageContext__storage_ {
  uint32_t _has_storage_[1];
  LatLongRect *latLongRect;
  NSMutableArray *languageHintsArray;
} ImageContext__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latLongRect",
        .number = ImageContext_FieldNumber_LatLongRect,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(ImageContext__storage_, latLongRect),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(LatLongRect),
        .fieldOptions = NULL,
      },
      {
        .name = "languageHintsArray",
        .number = ImageContext_FieldNumber_LanguageHintsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
        .offset = offsetof(ImageContext__storage_, languageHintsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageContext class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(ImageContext__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AnnotateImageRequest

@implementation AnnotateImageRequest

@dynamic hasImage, image;
@dynamic featuresArray, featuresArray_Count;
@dynamic hasImageContext, imageContext;

typedef struct AnnotateImageRequest__storage_ {
  uint32_t _has_storage_[1];
  Image *image;
  NSMutableArray *featuresArray;
  ImageContext *imageContext;
} AnnotateImageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "image",
        .number = AnnotateImageRequest_FieldNumber_Image,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageRequest__storage_, image),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Image),
        .fieldOptions = NULL,
      },
      {
        .name = "featuresArray",
        .number = AnnotateImageRequest_FieldNumber_FeaturesArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageRequest__storage_, featuresArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Feature),
        .fieldOptions = NULL,
      },
      {
        .name = "imageContext",
        .number = AnnotateImageRequest_FieldNumber_ImageContext,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageRequest__storage_, imageContext),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ImageContext),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AnnotateImageRequest class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(AnnotateImageRequest__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AnnotateImageResponse

@implementation AnnotateImageResponse

@dynamic faceAnnotationsArray, faceAnnotationsArray_Count;
@dynamic landmarkAnnotationsArray, landmarkAnnotationsArray_Count;
@dynamic logoAnnotationsArray, logoAnnotationsArray_Count;
@dynamic labelAnnotationsArray, labelAnnotationsArray_Count;
@dynamic textAnnotationsArray, textAnnotationsArray_Count;
@dynamic hasSafeSearchAnnotation, safeSearchAnnotation;
@dynamic hasImagePropertiesAnnotation, imagePropertiesAnnotation;
@dynamic hasError, error;

typedef struct AnnotateImageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *faceAnnotationsArray;
  NSMutableArray *landmarkAnnotationsArray;
  NSMutableArray *logoAnnotationsArray;
  NSMutableArray *labelAnnotationsArray;
  NSMutableArray *textAnnotationsArray;
  SafeSearchAnnotation *safeSearchAnnotation;
  ImageProperties *imagePropertiesAnnotation;
  Status *error;
} AnnotateImageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "faceAnnotationsArray",
        .number = AnnotateImageResponse_FieldNumber_FaceAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageResponse__storage_, faceAnnotationsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(FaceAnnotation),
        .fieldOptions = NULL,
      },
      {
        .name = "landmarkAnnotationsArray",
        .number = AnnotateImageResponse_FieldNumber_LandmarkAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageResponse__storage_, landmarkAnnotationsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(EntityAnnotation),
        .fieldOptions = NULL,
      },
      {
        .name = "logoAnnotationsArray",
        .number = AnnotateImageResponse_FieldNumber_LogoAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageResponse__storage_, logoAnnotationsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(EntityAnnotation),
        .fieldOptions = NULL,
      },
      {
        .name = "labelAnnotationsArray",
        .number = AnnotateImageResponse_FieldNumber_LabelAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageResponse__storage_, labelAnnotationsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(EntityAnnotation),
        .fieldOptions = NULL,
      },
      {
        .name = "textAnnotationsArray",
        .number = AnnotateImageResponse_FieldNumber_TextAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageResponse__storage_, textAnnotationsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(EntityAnnotation),
        .fieldOptions = NULL,
      },
      {
        .name = "safeSearchAnnotation",
        .number = AnnotateImageResponse_FieldNumber_SafeSearchAnnotation,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageResponse__storage_, safeSearchAnnotation),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(SafeSearchAnnotation),
        .fieldOptions = NULL,
      },
      {
        .name = "imagePropertiesAnnotation",
        .number = AnnotateImageResponse_FieldNumber_ImagePropertiesAnnotation,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageResponse__storage_, imagePropertiesAnnotation),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ImageProperties),
        .fieldOptions = NULL,
      },
      {
        .name = "error",
        .number = AnnotateImageResponse_FieldNumber_Error,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(AnnotateImageResponse__storage_, error),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Status),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AnnotateImageResponse class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(AnnotateImageResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchAnnotateImagesRequest

@implementation BatchAnnotateImagesRequest

@dynamic requestsArray, requestsArray_Count;
@dynamic user;

typedef struct BatchAnnotateImagesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *requestsArray;
  NSString *user;
} BatchAnnotateImagesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestsArray",
        .number = BatchAnnotateImagesRequest_FieldNumber_RequestsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(BatchAnnotateImagesRequest__storage_, requestsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(AnnotateImageRequest),
        .fieldOptions = NULL,
      },
      {
        .name = "user",
        .number = BatchAnnotateImagesRequest_FieldNumber_User,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(BatchAnnotateImagesRequest__storage_, user),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchAnnotateImagesRequest class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(BatchAnnotateImagesRequest__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchAnnotateImagesResponse

@implementation BatchAnnotateImagesResponse

@dynamic responsesArray, responsesArray_Count;

typedef struct BatchAnnotateImagesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *responsesArray;
} BatchAnnotateImagesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responsesArray",
        .number = BatchAnnotateImagesResponse_FieldNumber_ResponsesArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(BatchAnnotateImagesResponse__storage_, responsesArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(AnnotateImageResponse),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchAnnotateImagesResponse class]
                                     rootClass:[ImageAnnotatorRoot class]
                                          file:ImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(BatchAnnotateImagesResponse__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)
